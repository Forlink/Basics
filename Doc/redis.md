##Rdeis
##第一部分
###简单的动态字符串
redis自己构建了一个简单的动态字符串（SDS）的抽象类型，并将SD用作Redis的默认字符串表示。<br/>
SDS除了用来保存数据库中的字符串值外，SDS还被用作缓冲区(buffer)：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现的。<br>
#####SDS的定义
每一个sds.h/sdshdr结构表示一个SDS值：<br>

	struct sdshdr {
		//记录buf数组中使用字节的数量
		//等于SDS所保存字符串的长度
		int len;    //n表示这个SDS保存了一个N字节长的字符串
		//记录buf数组中未使用字节的数量
		int free;   //0表示这个SDS没有分配任何未使用空间。
		//字节数组，用于保存字符串
		char buf[];     //遵循C字符串以空字符结尾的惯例，保存空字符的1字节不计算在SDS的属性里面。
	}
######常数复杂度获取字符串长度
因为C字符串不记录自身的长度信息，所以为了获取一个C字符串长度需要变量整个字符串。<br>
SDS本身记录字符串长度。<br>
#####杜绝缓冲区溢出
C字符串不记录自身长度容易造成缓冲区溢出。<br>
SDS空间分配策略完全杜绝了发生缓冲溢出的可能性：档SDS API需要对SDS进行修改时，API会先检查SDS的空间十分满足修改所需的要求，如果不满足，API会自动将SDS的空间扩展至执行修改所需大小。<br>
#####减少修改字符串时带来的内存重分配次数

#####C字符串和SDS之间的区别
<p>
    C字符串
    <p>获取字符串长度的复杂度为0(N)</p>
    <p>API是不安全的，可能会造成缓冲区溢出</p>
    <p>修改字符串长度N次必须执行N次内存重分配</p>
    <p>只能保存文本数据</p>
    <p>可以使用所有&lt;string.h&gt;库中的函数</p>
</p>
<p>
    SDS
    <p>获取字符串长度的复杂度为0(1)</p>
    <p>API是安全的，不会造成缓冲区溢出</p>
    <p>修改字符串长度N次最多需要执行N次内存重分配</p>
    <p>可以保存文本或者二进制数据</p>
    <p>可以使用一部分&lt;string.h&gt;库中的函数</p>
</p>
#####重点回顾
Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（简单动态字符串）作为字符串表示。<br>
1>常数复杂度获取字符串长度
2>杜绝缓冲区溢出
3>减少修改字符串长度时所需的内存重分配次数
4>二进制安全
5>兼容部分C字符串函数。
###链表
链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活的调整链表的长度。<br>
#####链表和链表节点的实现
每个链表节点使用一个adlist.h/listNode结构来表示：

    typedef struct listNode {
        //前置节点
        struct listNode * prev;
        //后置节点
        struct listNode * next;
        //节点的值
        void * value;
    }listNode;
使用adlies.h/list来持有链表操作更方便：

    typedef struct list {
        //表头节点
        listNode * head;
        //表尾节点
        listNode * tail;
        //链表所包含的节点数量
        unsigned long len;
        //节点值复制函数
        void * (*dup) (void * ptr);
        //节点值释放函数
        void (*free) (void * ptr);
        //节点值对此函数
        int (*match) (void * ptr, void * key);
    }list;
list结构为链表表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：<br>
dup函数用于复制链表节点所保存的值;<br>
free函数用于释放链表节点所保存的值;<br>
match函数则用于对吧链表节点所保存的值和另一个输入值是否相等。<br>
<p>
Redis的链表实现的特征可以总结如下：
    <p>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</p>
    <p>无环：表节点的prev指针和表结尾节点的next指针都指向NULL，对链表的访问以NULL为终点</p>
    <p>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和尾节点的复杂度O(1)</p>
    <p>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表节点数量的复杂度为O(1)</p>
    <p>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性节点值设置类型特定函数，所有链表可以用于保存各种不同类型的值</p>
</p>
#####重点回顾
链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。<br>
每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。<br>
每一个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。<br>
因为连接表头节点的前置节点和表结尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表<br>
通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。
###字典
字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对的抽象数据结构。<br>
####字典的实现
Redis的字典使用哈希表作为底层实现一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。
#####哈希表
Redis字典所使用的哈希表由dict.h/dictht结构定义：

    typedef struct dictht {
        //哈希表数组
        dictEntry **table;
        //哈希表大小
        unsigned long size;
        //哈希表大小掩码，用于计算索引值
        //总是等于size-1
        unsigned long sizemask;
        //该哈希表已有节点的数量
        unsigned long used;
    }dictht;
#####哈希表节点
哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：
    
    typedef struct dictEntry {
        //键
        void *key;
        //值
        union{
            void *val;
            uint64_tu64;
            int64_ts64;
        }
        //指向下个哈希表节点，形成链表
        struct dictEntry *next;
    }dictEntry;
#####字典
Redis中的字典由dict.h/dict结构表示

    typedef struct dict {
        //类型特定函数
        dictType *type;
        //私有数据
        void *privdata;
        //哈希表
        dictht ht[2];
        //rehash 索引
        //当rehash不在进行时，值为-1
        in trehashidx; /* rehashing not in progress if rehashidx == -1 */        
    }dict;
####哈希算法
当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将要包含新键值对的哈希表节点放到哈希表数组的指定索引上面。	
####解决键冲突
当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。<br>
Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。
####rehash
随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相对的扩展或者收缩。<br>
扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：<br>
	
	1>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）:<br>
		如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2的n次方幂。<br>
		如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2的n次方幂。<br>
	2>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
	3>当ht[0]包含的所有的键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0],将ht[1]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。<br>
<b>哈希表的扩展与收缩</b><br>
当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：<br>
1>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。<br>
2>服务器目前正在执行BGSAVE命令或者BGREWRITAOF命令，并且哈希表的负载因子大于等于5。<br>
#####重点回顾
字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。<br>
Redis中的字段使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。<br>
当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值<br>
在对哈希表进行扩展或者收缩操作时，程序需要将现在哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式的完成的。
###跳跃表
跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>
跳跃表支持平均O(logN)、最坏O(N)复杂的节点查找，还可以通过顺序性操作来批量处理节点。<br>
Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。<br>
####跳跃表的实现
Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。<br>
####跳跃表节点
跳跃表节点的实现redis.h/zskiplistNode结构定义：<br>

	typedef struct zskiplistNode {
		//是
		struct zskiplistLevel {
			//前进指针
			struct zskiplistNdoe *forward;
			//跨度
			unsigned int span;
		} level[];
		//后进指针
		struct zskiplistNode *backward;
		//分值
		double score;
	}  zsiplistNode;
#####重点回顾
跳跃表是有序集合的底层实现之一。<br>
Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表 头节点、表尾节点、长度）而zskiplistNode则用于表示跳跃表节点。<br>
每一个跳跃表节点的层高都是1至32之间的随机数。<br>
在同一个跳跃表中，多个节点可以包含相同的分值，节点按照成员对象的大小进行排序。
###整数集合
整数集合(intset)是Redis用于保存整数值得集合抽象数据结构，它可以保存类型为int16_t、int32_t
int64_t的整数值，并且保证集合中不会出现重复元素。<br>
每个intset.h/intset结构表示一个整数集合:<br>

	typedef struct intset {
		//编码方式
		uint32_t encoding;
		//集合包含的元素数量
		uint32_t length;
		//保存元素的数组
		int8_t contents[];
	} intset;
contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值得大小从小到大有序地排列，并且数组中不包含任何重复项。<br>
#####重点回顾
整数集合是集合键的底层实现之一。<br>
整数集合的底层实现为数组，这个数组以有序、不重复的方式保存集合元素，在有需要时，程序会根据添加元素的类型，改变这个数组的类型。<br>
升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存<br>
整数集合只支持升级操作，不支持降级操作。
###压缩列表
压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。<br>
####压缩列表的构成
压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点(entry)，每个节点可以保存一个字节数组或者一个整数值。<br>
#####重点回顾
压缩列表是一种为节约内存而开发的顺序型数据结构。<br>
压缩列表被用作列表键和哈希键的底层实现之一。<br>
压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。<br>
添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现大的几率并不高。
###对象

#####重点回顾
Redis数据库中的每个键值对的键和值都是一个对象。<br>
Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率<br>
服务器在执行某些命令之前吗，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。<br>
Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会自动释放。<br>
Redis会共享值为0到9999的字符串对象<br>
对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。
##第二部分
###单机数据库的实现
###数据库
####服务器中的数据库
<p>
	Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：
</p>
	struct redisServer {
		//一个数组，保存着服务器中的所有数据库
		redisDb *db;
	}
<p>在初始化服务器时，程序会根据服务状态的dbnum属性来决定应该创建多少个数据库：</p>
	struct redisServer {
		//服务器的数据库数量
		int dbnum;
	}
####切换数据库
SELECT n	(n为数据库数)
默认配置文件初始化有16个数据库
####数据库键空间
redi是一个键值对数据库服务器，服务器中的每个数据库都由redis.h/redisDb结构表示，其中，redis结构的dict字典保存了数据库中的所有键值对。这个字典称之为键空间。
<p>
	键空间和用户所见的数据库是直接对应的：
	<p>键空间的键也就是数据库的键，每个键都是一个字符串对象</p>
	<p>键空间的值也就是数据库的值，每个值可以是字符串对象，列表对象，哈希表对象</p>
</p>
#####读写键空间时维护操作
<p>
当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作：
	<p>
	在读取一个键之后，服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats 命令的keyspace_hits属性和keyspace_misses属性中查看。
	</p>
	<p>
	在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime<key> 命令查看键key的闲置时间。
	</p>
	<p>
	如果服务器在读取一个键时发现该键已经过期，那么会先删除这个过期键，然后才执行余下的操作
	</p>
	<p>
	如果有客户端使用WATCH命令监视某个键，那么服务器在对键进行修改后，会将这个键标记为脏(dirty)，从而让事物程序注意到这个键已经被修改过。
	</p>
	<p>
	服务器每次修改一个键之后，都会对脏(dirty)键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作
	</p>
	<p>
	如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。
	</p>
</p>
####设置键的生存时间或过期时间
<p>
	通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间(Time to Live ,TTL),在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键
</p>
####过期键删除策略
<p>
	定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作
</p>
<p>
	惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期就返回键
</p>
<p>
	定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面过期的键。至于要删除多少过期键，以及要检查多少个数据库，则由算法觉得
</p>
#####定时删除
<p>定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快的被删除，并释放过期键所占用的内存。</P>
<p>定时删除策略的缺点是，它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间</p>
#####惰性删除
<p>惰性删除对CPU时间来说最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间</p>
<p>缺点：它对内存不友好：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放</p>
#####定期删除
<p>
	定时删除策略是前两种策略的一种整合和折中：
	<p>
	定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
	</p>
	<p>
	除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费
	</p>
</p>
#####发送通知的实现
<p>
	以下是notifyKeyspaceEvent函数的伪代码实现：
</p>
	def notifyKeyspaceEvent(type, event, key, dbid):
		// 如果给定的通知不是服务器允许发送的通知，那么直接返回
		if not(server.notify_keyspace_eventd & type):
			return
		// 发送键空间通知
		if server.notify_keyspace_event & REDIS_NOTIFY_KEYSPACE：
			// 将通知发送给频道 __keyspace@<dbid>__:<key>
			// 内容为键所发生的事件 <event>

			// 构建频道名字
			chan = "__keyspqce@{dbid}__:{key}".format(dbid=dbid, key=key)
			//发送通知
			pubsubPublishMaessage(chan, event)
		// 发送键事件通知
		if server.notify_keyspace_events & REDIS_NOTIFY_KEYEVENT:
			//将通知发送给频道 __keyevent@<dbid>__:<event>
			//内容为发生事件的键<key>

			//构建频道名字
			chan = "__keyevent@{dbid}__:{event}".format(dbid=dbid, event=event)

			//发送通知
			pubsubPublishMessage(chan, key)
#####重点回顾
<p>
Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。
</p>
<p>
客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同数据库
</p>
<p>
数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键过期时间
</p>
<p>
因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的
</p>
<p>
数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象分别对应字符串键、哈希表键、集合键、列表键和有序集合键。
</p>
<p>
expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳
</p>
<p>
Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键
</p>
<p>
执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。
</p>
<p>
执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键
</p>
<p>
当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式的删除过期键
</p>
<p>
当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键
</p>
<p>
从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务的一致性
</p>
<p>
当redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知
</p>
###RDB持久化
<p>Reids提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失</p>
<p>
RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中，RDB持久化功能生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。
</p>
<p>
	AOF文件的更新频率通常比RDB文件的更新频率高：
	<p>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态</p>
	<p>只有在AOF持久化功能处于关闭状态时，那么服务器才会使用RDB文件还原数据库状态</p>
</p>
#详细内容缺失（后期补充）
####重点回顾
<ul>
<li>RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。</li>
<li>SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</li>
<li>BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。</li>
<li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</li>
<li>RDB文件是一个经过压缩的二进制文件，由多个部分组成。结构：REDIS、版本号、数据库、EOF标识符、文件的校验码</li>
<li>
对于不同类型的键值对，RDB文件会使用不同的方式来保护它们。
<p>
字符串对象：
压缩：len、string
无压缩：REDIS_RDB_ENC_LZF、压缩后字符串长度、压缩前字符串长度、压缩后的字符串
</p>
<p>
列表对象：
list_lenght(列表长度)、字符数|字符
</p>
<p>
集合对象：
set_size(集合大小)、字符数|字符
</p>
<p>
哈希对象：
hash_size(哈希对象大小)、key字符数|key、value字符数|value
</p>
<p>
有序集合：
sorted_set_size(有序集合大小)、member字符数|member、score字符数|score
</p>
</li>
</ul>
###AOF持久化
<p>
AOF持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器执行的写命令来记录数据库状态的。
</p>
####AOF持久化的实现
<p>AOF持久化功能的实现可以分为命令追加(append)、文件写入、文件同步(sync)三个步骤</p>
#####命令追加
<p>
当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。
</p>
#####AOF文件的写入与同步
<p>
Redis的服务进程就是一个事件循环(loop)，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件负责执行像serverCron函数这样需要定时运行的函数。
</p>
<p>
因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区的内容写入和保存到AOF文件里面。
</p>
#####AOF持久化的效率和安全性
<p>
服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。
</p>
<p>
当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所有always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持续化也只会丢失一个事件循环中所产生的命令数据。
</p>
<p>
当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。
</p>
<p>
当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的fiushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。
</p>
####AOF文件的载入与数据还原
<p>
AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据状态。
</p>
<p>
Redis读取AOF文件并还原数据库状态详细步骤如下：
</p>
<ul>
<li>
1>创建一个不带网络连接的伪客户端(fake client):因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所有服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。
</li>
<li>
2>从AOF文件中分析并读取出一条写命令
</li>
<li>
3>使用伪客户端执行被读出的写命令。
</li>
<li>
4>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。
</li>
</ul>
####AOF重写
<p>
AOF持久化是通过被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机构成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。
</p>
####重点回顾
<p>
AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。
</p>
<p>
AOF文件中的所有命令都以Redis命令请求协议的格式保存。
</p>
<p>
命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。
</p>
<p>
appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。
</p>
<p>
服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。
</p>
<p>
AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。
</p>
<p>
AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。
</p>
<p>
在执行GBREWRITEAOF命令时Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。
</p>
###事件
<p>
文件事件(file event):Redis服务器通过套接字与客户端(或者其他Redis服务器)进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端(或者其他服务器)的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。
</p>
<p>
时间事件(time event)：Redis服务器中的一些操作(比如serverCron函数)需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。
</p>
