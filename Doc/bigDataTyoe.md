##数据结构
###线性表
***
<p>线性表（List）:零个或多个数据元素的有限序列</p>
<p>
<p>ADT线性表(List)</p>
<p>
Data
	<p>
	线性表的数据对象集合为{a1,a2……an},每个元素的类型均为DataType.其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后既元素。数据元素之间的关系是一对一的关系。
	</p>
	<p>
	Operation
	<p>IniList(*L);			初始化操作，建立一个空的线性表L.</p>
	<p>ListEmpty(L);		若线性表为空，返回true,否则返回false</p>
	<p>ClearList(*L);		将线性表清空</p>
	<p>GetElem(L,i,*e);		将线性表L中的第i个位置元素值返回给e</p>
	<p>LocateElem(L,e); 	将线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。</p>
	<p>ListInsert(*L,i,e);  在线性表L中的第i个位置插入新元素e</p>
	<p>ListDelete(*L,i,e);  删除线性表L中第i个位置元素，并用e返回其值</p>
	<p>ListLength(L);	    返回线性表L的元素个数</p>
	endADT
	</p>
</p>
</p>
####线性表的顺序存储结构
#####顺序存储定义
<p>
线性表的顺序存储结构，指得是用一段地址连续的存储单元依次存储线性表的数据元素。
</p>
#####顺序存储方式
	#define MAXSIZE 20 					/*存储空间初始分配量*/
	typedef int ElemType;				/*ElenType类型根据实际情况而定，这里假设为int*/
	typedef struct
	{
		ElemType data[MAXSIZE];			/*数组存储数据元素，最大值为MAXSIZE*/
		int length;						/*线性表当前长度*/
	}SqList;
<p>
顺序存储结构需要三个属性：
<ul>
<li>存储空间的起始位置：数组data,它的存储位置就是存储空间的存储位置</li>
<li>线性表的最大存储容量：数组长度MaxSize</li>
<li>线性表的当前长度：length</li>
</ul>
</p>
#####数据长度与线性表长度区别
<p>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的</p>
<p>在任意时刻，线性表的长度应该小于等于数组的长度</p>
#####地址计算方法
<p>用数组存储顺序意味着要分配固定长度的数组空间，由于线性表可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度</p>
<p>存储器中的每个存储单元都有自己的编号，这个编号称为地址</p>
#####插入算法的思路
<ul>
<li>如果插入位置不合理，抛出异常</li>
<li>如果线性表长度大于等于数组长度，则抛出异常或动态增加常量</li>
<li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置</li>
<li>将要插入元素填入位置i处</li>
<li>表长加1</li>
</ul>
#####删除算法的思路
<ul>
<li>如果删除位置不合理，抛出异常</li>
<li>取出删除元素</li>
<li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置</li>
<li>表长减1</li>
</ul>
#####线性表顺序存储结构的优缺点
<p>
优点：
<p>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</p>
<p>可以快速地存取表中任一位置的元素</p>
</p>
<p>
缺点：
<p>插入和删除操作需要移动大量元素</p>
<p>当线性表长度变化较大时，难以确定存储空间的容量</p>
<p>造成存储空间的“碎片”</p>
</p>
####线性表的链示存储结构
#####顺序存储结构不足的解决办法
<p>
所有的元素都不考虑相邻位置，哪有空位就到哪里，而只是让每个元素知道它下一个元素的位置在哪里，这样，我们可以在第一个元素时，就知道第二个元素的位置（内存地址），而找的它；在第二个元素时，再找到第三元素的位置（内存地址）。这样所有的元素就能通过遍历而找到。
</p>
#####线性表链示存储结构定义
<p>
线性表的链示存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置。
</p>
<p>
	<p>
	为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素ai的存储映像，称为节点（Node）。
	</p>
	<p>
	n个结点（ai的存储映像）链结成一个链表，即为线性表(a1,a2……,an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。
	</p>
	<p>
	链表中第一个结点的存储位置叫做头指针。
	</p>
	<p>
	单链表的第一个结点前附设一个结点，称为头结点。
	</p>
</p>
#####头指针与头结点的异同
<p>
头指针
	<p>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。</p>
	<p>头指针具有标识作用，所以常用头指针冠以链表的名字</p>
	<p>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</p>
</p>
<p>
头结点
	<p>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</p>
	<p>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</p>
	<p>头结点不一定是链表必须要素</p>
</p>
#####线性表链式存储结构代码描述
	/*线性表的单链表存储结构*/
	typedef struct Node
	{
		ElemType data;
		struct Node *next;
	}Node;
	typedef struct Node *LinkList;	/*定义 LinkList*/
<p>结点由存放数据元素的数据域存放后继结点地址的指针域组成</p>
#####单链表的整表创建
<p>
单链表整表创建的算法思路：
<p>1.声明一结点P和计数器变量i</p>
<p>2.初始化一空链表L</p>
<p>3.让L的头结点的指针指向NULL，即建立一个带头结点的单链表；</p>
<p>
4.循环：
<ul>
<li>生成一新结点赋值给P</li>
<li>随机生成一数字赋值给P的数据域p->data</li>
<li>将P插入到头结点与前一新结点之间</li>
</ul>
</p>
</p>
#####单链表的整表删除
<p>
单链表整表删除的算法思路：
<p>1.声明一结点P和计q</p>
<p>2.将第一个结点赋值给P</p>
</p>
<p>
3.循环：
<ul>
<li>将下一结点赋值给q</li>
<li>释放p</li>
<li>将q赋值给p</li>
</ul>
</p>
</p>
#####单链表结构与顺序存储结构优缺点
<ul>
存储分配方式
<li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li>
<li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li>
</ul>
<ul>
时间性能
<ul>
查找
<li>顺序存储结构0(1)</li>
<li>单链表0(n)</li>
</ul>
<ul>
插入和删除
<li>顺序存储结构需要平均移动表长一半的元素，时间为0(n)</li>
<li>单链表在线出某位置的指针后，插入和删除时间仅为0(1)</li>
</ul>
</ul>
<ul>
空间性能
<li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢</li>
<li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</li>
</ul>
####静态链表优缺点
<p>
优点：
	<p>
	在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。
	</p>
</p>
<p>
缺点：
	<p>
	没有解决连续存储分配带来的表长难以确定的问题
	</p>
	<p>
	失去了顺序存储结构随机存取的特性
	</p>
</p>
####循环链表
<p>
将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。
</p>
####双向链表
<p>
双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。
</p>









